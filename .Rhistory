library(comtradr) # An API for UN Comtrade Data
# Data----
data <- read.csv("C:/Users/jlrod/Documents/Networks and the macroeconomy/NetworksAndTheMacroeconomy/SCIAN-TIGIE-RESUMEN.csv" ,
header = TRUE) # Aquí estoy importanto la hoja con la relación SCIAN 4 dígitos <-> TIGIE 6 dígitos
hs2012 <- as.character(unique(unlist(data))) # Para crear un vector string con los códigos únicos que necesitaremos descargar
hs2012 <- hs2012[!is.na(hs2012)]
test_hs2012 <- hs2012[2001:4000] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
summary(test_hs2012)
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE)0
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE)
prueba
View(prueba)
ct_commodity_db_type()
test_hs2012 <- hs2012[1:2000] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE)
View(prueba)
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE , return_code = TRUE)
is(prueba == test_hs2012)
data1 <- c(prueba , test_hs2012)
data1 <- unique(data1)
View(test_hs2012)
igual <- as.numeric(test_hs2012 = prueba)
igual <- as.numeric(test_hs2012 == prueba)
igual
test_hs2012 <- hs2012[1:2000] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
iteradores <- seq(1 , 40 , by = 20) # Para saltar los iteradores
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,            # Nota: Cuando las bases salen vacías es porque
end_date = "all"))              # nuestro código tiene dos ceros al final, es decir,
# en el HS2012 solo se reconoce por los primeros 4 dígitos.
Sys.sleep(1) # Para "dormir" el sistema un segundo
# Posteriormente arreglaremos eso.
}
View(comtrade_1)
summary(comtrade_1$commodity_code)
comtrade_1$commodity_code <- as.factor(comtrade_1$commodity_code)
summary(comtrade_1$commodity_code)
View(comtrade_1)
View(comtrade_21)
ct_get_remaining_hourly_queries()
ct_get_reset_time()
ct_get_reset_time()
ct_get_remaining_hourly_queries()
ct_get_remaining_hourly_queries()
library(dplyr) # For data wrangling
bind_rows(comtrade_1 , comtrade_1)
for (i in iteradores){
comtrade[i] <- paste("comtrade" , i , sep = "_")
}
iteradores <- seq(1 , 40 , by = 20) # Para saltar los iteradores
comtrade[]
comtrade <- data.frame()
for (i in iteradores){
comtrade[i] <- paste("comtrade" , i , sep = "_")
}
comtrade <- data.frame(row.names = names(comtrade_1))
View(comtrade)
comtrade <- data.frame(names = names(comtrade_1))
View(comtrade)
comtrade <- data.frame(names(comtrade_1))
do.call(rbind.data.frame, mget(ls(pattern = "comtrade_")))
do.call(rbind.data.frame, mget(paste0("comtrade_", seq_along(iteradores))))
test_hs2012 <- hs2012[1:60] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
iteradores <- seq(1 , 60 , by = 20) # Para saltar los iteradores
interadores_j <- seq(1 , 60 , by = 40)
iteradores_j
iteradores_j <- seq(1 , 60 , by = 40)
iteradores_j
for (j in iteradores_j){
comtrade <- rows_bind(paste("comtrade" , j , sep = "_") , paste("comtrade" , j+20 , sep = "_"))
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE)
}
for (j in iteradores_j){
comtrade <- bind_rows(paste("comtrade" , j , sep = "_") , paste("comtrade" , j+20 , sep = "_"))
prueba <- ct_commodity_lookup(test_hs2012 , return_char = TRUE)
}
iteradores <- seq(1 , 60 , by = 20) # Para saltar los iteradores
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,
end_date = "all"))
comtrade <- list()
comtrade[[]]
Sys.sleep(1) # Para "dormir" el sistema un segundo
}
test_hs2012 <- hs2012[1:60] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
iteradores <- seq(1 , 60 , by = 20) # Para saltar los iteradores
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,
end_date = "all"))
Sys.sleep(1) # Para "dormir" el sistema un segundo
}
View(comtrade_21)
View(comtrade_41)
View(comtrade_41)
View(comtrade_1)
library(comtradr) # An API for UN Comtrade Data
library(dplyr)
data <- read.csv("C:/Users/jlrod/Documents/Networks and the macroeconomy/NetworksAndTheMacroeconomy/SCIAN-TIGIE-RESUMEN.csv" ,
header = TRUE) # Aquí estoy importanto la hoja con la relación SCIAN 4 dígitos <-> TIGIE 6 dígitos
hs2012 <- as.character(unique(unlist(data))) # Para crear un vector string con los códigos únicos que necesitaremos descargar
hs2012 <- hs2012[!is.na(hs2012)] # Eliminamos NAs
test_hs2012 <- hs2012[1:60] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
iteradores <- seq(1 , 60 , by = 20) # Para saltar los iteradores
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,
end_date = "all"))
Sys.sleep(1) # Para "dormir" el sistema un segundo
}
rlang::last_error()
ct_get_remaining_hourly_queries()
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,
end_date = "all"))
Sys.sleep(1) # Para "dormir" el sistema un segundo
}
test_hs2012 <- hs2012[1:40] # Me quedo con 40 códigos para hacer los experimentos con el loop sin acabarme las queries :S
iteradores <- seq(1 , 40 , by = 20) # Para saltar los iteradores
for (i in iteradores) {             # Para cada elemento de test_hs2012, hacer:
name <- paste("comtrade" , i , sep = "_")  # Un objeto (que será data frame) que se llame comtrade_i, donde i
# es el número de iteración.
assign(name , ct_search(reporters = "USA" ,
partners = c("Mexico" , "China") ,  # Assign se interpreta así:
trade_direction = "imports" ,       # assign(nombre del objeto a crear , valores del objeto)
freq = "annual" ,                   # Rasultado: Un data frame por iteración.
commod_codes = test_hs2012[i:(i+19)] ,  # Extraer la serie del elemento i
start_date = "all" ,
end_date = "all"))
Sys.sleep(1) # Para "dormir" el sistema un segundo
}
